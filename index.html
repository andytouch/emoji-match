<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Match-3 Animated Grid with Delay</title>
<style>
  body {
    display: flex;
    justify-content: center;
    padding: 20px;
    background: #f0f0f0;
    font-family: monospace;
  }

  #grid {
    position: relative;
    width: 1000px; /* 20 cols √ó 50px */
    height: 1000px; /* 20 rows √ó 50px */
    border: 2px solid #ccc;
    background: #fff;
  }

  .cell {
    position: absolute;
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 36px;
    cursor: pointer;
    transition: top 0.3s ease;
    user-select: none;
  }
</style>
</head>
<body>

<div id="grid"></div>

<script>
const fruits = ['üçé','üçå','üçá','üçâ','üçì','üçí','üçë','ü•≠','üçç','ü•ù'];
const gridWidth = 20;
const gridHeight = 20;
const grid = document.getElementById('grid');
const cells = [];

// Create grid
for (let y = 0; y < gridHeight; y++) {
  for (let x = 0; x < gridWidth; x++) {
    const cell = createCell(x, y, randomFruit());
    cells.push(cell);
    grid.appendChild(cell);
  }
}

// Helper to create a fruit cell
function createCell(x, y, fruit) {
  const span = document.createElement('span');
  span.className = 'cell';
  span.dataset.x = x;
  span.dataset.y = y;
  span.dataset.fruit = fruit;
  span.textContent = fruit;
  span.style.left = `${x * 50}px`;
  span.style.top = `${y * 50}px`;

  span.addEventListener('click', () => {
    const f = span.dataset.fruit;
    if (!f) return;

    const group = getConnectedGroup(parseInt(span.dataset.x), parseInt(span.dataset.y), f);
    if (group.size >= 3) {
      // Delete the group visually
      for (let key of group) {
        const [gx, gy] = key.split(',').map(Number);
        const c = getCell(gx, gy);
        c.dataset.fruit = '';
        c.textContent = '';
      }
      // Delay before gravity
      setTimeout(() => {
        applyGravity();
      }, 300); // 300ms delay
    }
  });

  return span;
}

// Random fruit
function randomFruit() {
  return fruits[Math.floor(Math.random() * fruits.length)];
}

// Get cell at (x,y)
function getCell(x, y) {
  if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return null;
  return cells[y * gridWidth + x];
}

// Get all connected fruits (4-way)
function getConnectedGroup(x, y, fruit, visited = new Set()) {
  const key = `${x},${y}`;
  if (visited.has(key)) return visited;
  const cell = getCell(x, y);
  if (!cell || cell.dataset.fruit !== fruit) return visited;

  visited.add(key);
  getConnectedGroup(x+1, y, fruit, visited);
  getConnectedGroup(x-1, y, fruit, visited);
  getConnectedGroup(x, y+1, fruit, visited);
  getConnectedGroup(x, y-1, fruit, visited);
  return visited;
}

// Gravity with smooth animation
function applyGravity() {
  for (let x = 0; x < gridWidth; x++) {
    let emptySlots = 0;
    for (let y = gridHeight - 1; y >= 0; y--) {
      const cell = getCell(x, y);
      if (!cell.dataset.fruit) {
        emptySlots++;
      } else if (emptySlots > 0) {
        const targetCell = getCell(x, y + emptySlots);
        targetCell.dataset.fruit = cell.dataset.fruit;
        targetCell.textContent = cell.dataset.fruit;
        targetCell.style.top = `${(y + emptySlots) * 50}px`;

        cell.dataset.fruit = '';
        cell.textContent = '';
      }
    }

    // Fill new fruits at the top
    for (let y = 0; y < emptySlots; y++) {
      const cell = getCell(x, y);
      const newFruit = randomFruit();
      cell.dataset.fruit = newFruit;
      cell.textContent = newFruit;

      // Start above grid
      cell.style.top = `${(y - emptySlots) * 50}px`;
      requestAnimationFrame(() => {
        cell.style.top = `${y * 50}px`;
      });
    }
  }
}
</script>

</body>
</html>
